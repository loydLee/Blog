# 前端笔记

## XML 与 JSON 的区别

```js
1、数据体积方面
   JSON相对于XML来说，数据的体积小，传递的速度更快些
2、数据交互方面
   JSON与javascript的交互更加方便，更容易解析处理，更好的数据交互
3、数据描述方面
   JSON对数据的描述性比XML较差
4、传输速度方面
   JSON的速度远远快于XML
```

## 如何解决跨域问题

```js
1、JSONP
   原理：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信，缺点为只支持get请求
2、cros
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问
3、通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域
   主域相同的使用document.domain
4、使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的
5、使用HTML5中新引进的window.postMessage方法来跨域传送数据

   除此之外，还有flash，，在服务器上这是代理页面等跨域方式，其中，window.name的方法既不复杂，又能兼容到所有的浏览器。**推荐使用**
```

## webpack 的两大特色

```js
1、code splitting(可以自动完成)
2、loader可以处理各种类型的静态文件，并且支持串联操作
```

webpack 具有 requirejs 以及 browserify 的功能，但是还有很多自己的特性

```js
1、对commonjs、amd、es6的语法做了兼容
2、对js、css、图片等资源文件都支持打包
3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持

4. 有独立的配置文件webpack.config.js

5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间

6. 支持 SourceUrls 和 SourceMaps，易于调试

7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活

8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快
```

## TCP 传输的三次握手四次挥手策略

### 三次握手

```js
为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。

发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。
最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
```

### 四次挥手

```js
第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。
```

## TCP 与 UDP 的区别

```js
TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。
```

## 作用域链

作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的

## 原生创建 ajax 的过程

```js
1、创建XMLHttpRequest对象,也就是创建一个异步调用对象.

2、创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.

3、设置响应HTTP请求状态变化的函数.

4、发送HTTP请求.

5、获取异步调用返回的数据.

6、使用JavaScript和DOM实现局部刷新.
```

## 渐进增强与优雅降级

```js
渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
```

## 常见 web 安全以及防护原理

### sql 注入

通过 sql 命令把表单提交到或输入域名或页面请求的查询字符串，以达到欺骗服务器执行恶意的 sql 命令
总体如下:

```js
1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。
3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
```

### XSS 原理及防范

```js
Xss(cross-site scripting)攻击指的是攻击者往web页面里插入恶意html或者javascript代码，比如：攻击者在论坛中放一个看似安全的链接，片区用户点击后，窃取cookie的用户私密信息，或者攻击者在了论坛中加一个恶意表单；
当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

防范方法:
        首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心吧hrml tag弄出来
        然而，避免直接在cookie中泄露用户隐私，例如email,密码等等
        其次，通过cookie和系统ip绑定来降低cookie泄露后的危险，这样攻击者得到的cookie没有实际价值，如果网站不需要在浏览器端对cookie进行操作，可以在set-cookie末尾加上httponly来防止javascript代码直接获取cookie
```

### XSS 与 CSRF 区别

XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF 是代替用户完成指定的动作，需要知道 ITA 用户页面的代码和数据包，而要完成一次 CSRF 攻击，受害者必须一次完成两个步骤:

```js
登录受信任网站A，并在本地生成cookie
在不登出A的情况下，访问危险网站B
```

CSRF 的防御：服务端的 CSRF 方法有很多，思路一致：在客户端页面增加伪随机数

### 通过验证码的方法进行

web worker 和 websocket

```js
worker主线程：
            1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。

            2.通过worker.postMessage( data ) 方法来向worker发送数据。

            3.绑定worker.onmessage方法来接收worker发送过来的数据。

            4.可以使用 worker.terminate() 来终止一个worker的执行。
websocket是web应用程序的传输协议，它提供了双向的，按序到达的数据流，其次，它是一个html5协议，websocket的链接是持久的，通过在客户端和服务器之间保持双工链接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询
```

### HTTP 与 HTTPS

```js
HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了HTTPS。

默认HTTP的端口号为80，HTTPS的端口号为443。

为什么HTTPS安全

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性
```

## 对前端模块化的认识

```js
AMD是requirejs在推广过程中对模块定义的规范化中产出，它是提前执行，推荐的风格是返回一个对象作为模块对象
Commonjs是seajs在推广过程中对模块定的的规范化中产出，它是延迟执行，commonjs的风格通过对module，exports或exports的属性复制来达到暴露模块对象的目的
```

## javascript 的垃圾回收方法

```js
标记清除(mark and sweep)
    javascript最常见的垃圾回收，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为‘进入环境’，当变量离开环境的时候(函数执行结束)将其标记为‘离开环境’
    垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量(闭包)，在这些完成之后仍存在标记的就是要删除的变量
引用计数(reference counting)
    在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。

    在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，
    也就是说只要涉及BOM及DOM就会出现循环引用问题。
```

## 性能优化

```js
代码层面优化
    用hash-table来优化查找
    少用全局变量
    用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能
    用setTimeout避免页面失去响应
    缓存DOM节点查找结果
    避免使用css expression
    避免全局查询
    避免使用with,(with会创建自己的作用域，会增加作用域链长度)
    多个变量声明合并
    避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率
    尽量避免写在HTML标签中写Style属性

移动端性能优化
    尽量使用css3动画，开启硬件加速。
    适当使用touch事件代替click事件。
    避免使用css3渐变阴影效果。
    可以用transform: translateZ(0)来开启硬件加速。
    不滥用Float。Float在渲染时计算量比较大，尽量减少使用
    不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。
    合理使用requestAnimationFrame动画代替setTimeout
    CSS中的属性（CSS3 transitions、CSS3 3D     transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加
    PC端的在移动端同样适用
```

## js 继承方式及其优缺点

```js
原型链继承的缺点:
    意识字面量重写原型绘中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数
借用构造函数(类式继承)
    借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起，因此需要原型链+借用构造函数的模式---组合继承
    这是一种比较常见的继承方法，背后的思路是使用原型链实现对原型属性和方法的继承
```

## HTTP 2.0

```js
HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
HTTP/2提供更多的加密支持
HTTP/2使用多路技术，允许多个消息在一个连接上同事交差
增加了头压缩(header compression),因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽
```

## defer 与 async

```js
defer并行加载js文件，会按照页面上script标签的顺序执行
async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行
```

## 设计模式

```js
工厂模式
    主要好处：可以消除对象间的耦合，通过使用工程方法而不是new关键字，将所有实例化的代码集中在一个位置防止代码重复
    工厂模式解决了重复实例化的问题，但存在识别问题：无法弄清楚他们到底是哪一个对象的实例
    function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.profession = profession;
        obj.move = function () {
            return this.name + ' at ' + this.age + ' engaged in ' + this.profession;
        };
        return obj;
    }
    var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例

构造函数模式
    使用构造函数的方法，即解决了重复实例化的问题，有解决了对象识别的 问题，该模式与工厂模式的不同之处在于：
    1、构造函数方法没有显示的创建对象(new object())
    2、直接将属性和方法赋值给this对象
    3、没有return
```

## 对闭包的理解

使用闭包主要是为了设计私有的变量和方法，闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露，在 js 中，函数即闭包，只有函数才会产生作用域的概念

```js
闭包有三个特性
    1、函数嵌套函数
    2、函数内部可以引用外部的参数和变量
    3、参数和变量不会被垃圾回收机制回收
```

## cookie 的弊端
